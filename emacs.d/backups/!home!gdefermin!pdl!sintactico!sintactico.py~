import json

f = open('gramatica.txt','r')
rules = {}
for line in f:
    line = line.replace("\n","")
    parts = line.split(" -> ")
#    print(parts)
    p2 = parts[1].split("|")
    i=0
    for p in p2:
        p2[i] = p.split(" ")
        p2[i] = [val for val in p2[i] if val != "" and val != "lambda"] # remove "" and "lambda"
        i+=1
    rules[parts[0].replace(" ","")] = p2
#print(rules)
f.close()


def cierre(items):
    result = dict(items)
    aux = dict(items)

    explored = []
    aux_explored = []
    done_something = True
    while(done_something):
        done_something = False
        for key in result:
            if(key in explored):
                continue
            aux_explored.append(key)
            for item in result[key]:
                index = item.index(".") + 1
                if(index < len(item) and item[index].isupper()):
                    for rule in rules[item[index]]:
                        r = list(rule)
                        r.insert(0,".")
                        if(item[index] in aux.keys()):
                            if(r not in aux[item[index]]):
                                aux[item[index]].append(r)
                                done_something = True
                                if item[index] in aux_explored:
                                    aux_explored.remove(item[index])
                        else:
                            aux[item[index]] = [r]
                            done_something = True
                        
        explored = list(aux_explored)
        result = dict(aux)
        
    return result

def goto(items, symbol):
    result = {}
    for key in items:
        for b in items[key]:
                index = b.index(".")
                if(index+1 == len(b) or b[index+1] != symbol):
                    continue
                c = list(b)
                c.remove(".")
                c.insert(index+1,".")
                if(key in result.keys()):
                    result[key].append(c)
                else:
                    result[key] = [c]
    return cierre(result)

f = open("symbols.txt","r")
symbols = []
for line in f:
    line = line.replace("\n","")
    symbols.append(line)
f.close()

def calc_collection():
    item = {}
    item["P'"] = [[".","P","eof"]]
    collection = []
    i0 = cierre(item)
    collection.append(i0)
    
    i=0
    while(i<len(collection)):
        #print("State:", i)
        #print("\t", collection[i])
        for sym in symbols:
            next_state = goto(collection[i],sym)
            if(next_state != {} and next_state not in collection):
                collection.append(next_state)
        i+=1
    jsonobject = json.dumps(collection)
    file = open(".collection","w")
    file.write(jsonobject)
    file.close()

def first(symlist):
    if(symlist == []):
        return ["lambda"]
    res = []
    i=0
    finished = False
    while not finished:
        finished = True
        if i == len(symlist):
            res.append("lambda")
            break
        if not symlist[i].isupper():
            res.append(symlist[i])
            return res
        for rule in rules[symlist[i]]:
            for sym in first(rule):
                if sym not in res:
                    res.append(sym)
            if "lambda" in res:
                res.remove("lambda")
                finished = False
        i+=1
    return res

def follow(symbol):
    res = []
    for key in rules:
        for rule in rules[key]:
            positions = []
            i=0
            for sym in rule:
                if sym == symbol:
                    positions.append(i)
                i+=1
            if positions == []:
                continue
            for pos in positions:
                if pos == len(rule)-1:
                    if key == symbol:
                        break
                    for sym in follow(key):
                        if sym not in res:
                            res.append(sym)
                else:
                    f = first(rule[pos+1:])
                    if "lambda" in f:
                        f.remove("lambda")
                        for sym in follow(key):
                            if sym not in res:
                                res.append(sym)
                    for sym in f:
                        if sym not in res:
                            res.append(sym)
    return res

def semaction(item):

    if(item == ['B','.','var','T','id']):
        return 1
    if(item == ['B','var','T','id', '.']):
        return 2
    if(item == ['B','if','(','E','.',')','S']):
        return 3
    if(item == ['B','S','.']):
        return 4
    if(item == ['B','if','(','E',')','S','.']):
        return 38
    if(item == ['B','while','(','E','.',')','X','{','C','}']):
        return 3
    if(item == ['B','while','(','E',')','X','{','C','}','.']):
        return 18
    if(item == ['S','id','=','E','.']):
        return 5
    if(item == ['S','return','Y','.']):
        return 6
    if(item == ['S','prompt','(','id','.',')']):
        return 7
    if(item == ['S','id','(','L','.',')']):
        return 8
    if(item == ['Y','E','.']):
        return 9
    if(item == ['T','int','.']):
        return 10
    if(item == ['T','bool','.']):
        return 11
    if(item == ['T','chars','.']):
        return 12
    if(item == ['L','E','Q','.']):
        return 13
    if(item == ['Q',',','E','Q','.']):
        return 14
    if(item == ['F','.','function','H','id','(','A',')','X','{','C','}']):
        return 1
    if(item == ['F','function','H','id','.','(','A',')','X','{','C','}']):
        return 15
    if(item == ['F','function','H','id','(','A','.',')','X','{','C','}']):
        return 16
    if(item == ['F','function','H','id','(','A',')','X','{','C','.','}']):
        return 17
    if(item == ['F','function','H','id','(','A',')','X','{','C','}','.']):
        return 18
    if(item == ['H','T','.']):
        return 19
    if(item == ['A','T','id','K','.']):
        return 21
    if(item == ['K',',','T','id','K','.']):
        return 22
    if(item == ['C','B','cr','C','.']):
        return 23
    if(item == ['C','B','.']):
        return 24
    if(item == ['C','cr','C','.']):
        return 25
    if(item == ['E','R','>','E','.']):
        return 27
    if(item == ['R','U','+','R','.']):
        return 28
    if(item == ['R','U','.']):
        return 29
    if(item == ['U','!','U','.']):
        return 30
    if(item == ['U','id','.']):
        return 32
    if(item == ['U','(','E','.',')']):
        return 33
    if(item == ['U','id','(','L','.',')']):
        return 34
    if(item == ['U','ct_int','.']):
        return 35
    if(item == ['U','ct_chars','.']):
        return 36
    if(item == ['U','--','id']):
        return 37

    return 0
    
    

def accion(state, symbol):
    if(symbol.isupper()):
        goto_state = goto(collection[state], symbol)
        i=0
        for s in collection:
            if(s == goto_state):
                break
            i+=1
        return ["goto", i]
    else:
        for key in collection[state]:
            for item in collection[state][key]:
                i=0
                for sym in item:
                    if sym == ".":
                        break
                    i+=1
                if i == len(item)-1:
                    #reducir
                    #print(key)
                    if symbol not in follow(key):
                        continue
                    result = {}

                    sitem = list(item)
                    sitem.insert(0,key)
                    x = semaction(sitem)
                    
                    right = list(item)
                    right.remove(".")
                    result = key + " -> "
                    for sym in right:
                        result+=sym + " "
                    return ["reducir", result, x]
                else:
                    if item[i+1] != symbol:
                        continue
                    #desplazar

                    sitem = list(item)
                    sitem.insert(0,key)
                    x = semaction(sitem)
                    
                    i=0
                    for state2 in collection:
                        gt = goto(collection[state], symbol)
                        if state2 == gt:
                            break
                        i+=1
                    if i == len(collection):
                        return ["void"]
                    return ["desplazar", i, x]
        return ["void"]

#print(accion(93,"eof"))
f = open(".collection","r")
coll = ""
for line in f:
    coll += line
collection = json.loads(coll)
f.close()

def save_collection():
    f = open("estados.txt", "w")
    i=0
    while(i<len(collection)):
        f.write("State:\n")
        f.write(str(i))
        f.write("\n")
        f.write("\t")
        f.write(str(collection[i]))
        f.write("\n")
        i+=1
    f.close()
